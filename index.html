<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>HiNOMAD WORLD v3</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #87CEEB; touch-action: none; font-family: 'Inter', sans-serif; }
        
        /* UI: ì ìˆ˜íŒ */
        #score-board {
            position: absolute; top: 20px; left: 20px;
            background: rgba(255, 255, 255, 0.9);
            padding: 10px 20px; border-radius: 30px;
            font-size: 1.2rem; font-weight: bold; color: #d32f2f;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            z-index: 20; display: flex; align-items: center; gap: 10px;
        }

        /* UI: ìŠ¤íƒ€ì¼ ë²„íŠ¼ */
        #style-btn {
            position: absolute; top: 20px; right: 20px;
            background: white; border: none;
            padding: 10px 15px; border-radius: 10px;
            font-weight: bold; cursor: pointer;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            z-index: 20; font-size: 1rem;
        }
        #style-btn:active { transform: scale(0.95); }

        /* UI: ê³µí†µ ëª¨ë‹¬ ìŠ¤íƒ€ì¼ */
        .modal {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9); color: white; padding: 30px; border-radius: 20px;
            text-align: center; display: none; z-index: 30; border: 2px solid #FFD700;
            width: 85%; max-width: 400px; box-shadow: 0 0 20px rgba(255, 215, 0, 0.5);
        }
        .modal h2 { margin-top: 0; color: #FFD700; font-size: 1.8rem; }
        .modal p { font-size: 1.1rem; line-height: 1.5; color: #eee; margin: 20px 0; }
        .modal-btn {
            padding: 12px 25px; background: #FFD700; border: none;
            border-radius: 30px; font-weight: bold; font-size: 1rem; cursor: pointer; color: black;
            margin-top: 10px; transition: transform 0.2s; text-decoration: none; display: inline-block;
        }
        .modal-btn:hover { transform: scale(1.05); background: #fff; }
        .close-icon {
            position: absolute; top: 15px; right: 20px; font-size: 24px; cursor: pointer; color: #aaa;
        }

        /* â˜… ë¯¸ì…˜ ì„±ê³µ ëª¨ë‹¬ ì „ìš© ìŠ¤íƒ€ì¼ â˜… */
        #mission-modal { border-color: #ff00ff; box-shadow: 0 0 30px rgba(255, 0, 255, 0.6); }
        #mission-modal h2 { color: #ff00ff; }
        #mission-modal .modal-btn { background: #ff00ff; color: white; }

        /* NPC ë§í’ì„  */
        #npc-label {
            position: absolute; background: #FFD700; color: #333; padding: 8px 16px; border-radius: 20px;
            font-weight: bold; cursor: pointer; box-shadow: 0 4px 10px rgba(0,0,0,0.2);
            transform: translate(-50%, -100%); display: none; z-index: 20; border: 2px solid white;
        }

        /* ê¸°íƒ€ UI */
        #loading {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: white; font-weight: bold; font-size: 20px; text-shadow: 1px 1px 2px black;
            transition: opacity 0.5s; pointer-events: none;
        }
        #splash-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(0, 100, 255, 0.5); opacity: 0;
            pointer-events: none; transition: opacity 0.2s; z-index: 5;
        }
        
        /* ì»¨íŠ¸ë¡¤ëŸ¬ */
        #joystick-zone { position: absolute; bottom: 30px; left: 30px; width: 120px; height: 120px; z-index: 15; background: rgba(255, 255, 255, 0.1); border-radius: 50%; border: 2px solid rgba(255, 255, 255, 0.3); }
        #jump-btn { position: absolute; bottom: 40px; right: 30px; width: 80px; height: 80px; background: rgba(255, 255, 255, 0.3); border: 2px solid white; border-radius: 50%; color: white; font-weight: bold; font-size: 14px; z-index: 15; cursor: pointer; display: flex; align-items: center; justify-content: center; user-select: none; }
        #jump-btn:active { background: rgba(0, 255, 255, 0.5); }
    </style>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/nipplejs/0.10.1/nipplejs.min.js"></script>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>
    <div id="loading">HiNOMAD WORLD (Setting Missions)...</div>
    <div id="splash-screen"></div>

    <div id="score-board">ğŸ 0 / 10</div>
    <button id="style-btn">ğŸ‘• Style</button>

    <div id="npc-label">About HiNOMAD ğŸ’¬</div>
    
    <div id="info-modal" class="modal">
        <span class="close-icon" id="close-info">&times;</span>
        <h2>HiNOMAD</h2>
        <p>IT ë¸Œëœë”© ì»´í¼ë‹ˆ<br>We create the future.</p>
        <button class="modal-btn" id="info-ok-btn">í™•ì¸</button>
    </div>

    <div id="mission-modal" class="modal">
        <span class="close-icon" id="close-mission">&times;</span>
        <h2>ğŸ‰ MISSION CLEAR!</h2>
        <p>ì‚¬ê³¼ 10ê°œë¥¼ ëª¨ë‘ ì°¾ìœ¼ì…¨ë„¤ìš”!<br>ì œì´í¬ì˜ ë” ë§ì€ ì´ì•¼ê¸°ë¥¼<br>ì¸ìŠ¤íƒ€ê·¸ë¨ì—ì„œ í™•ì¸í•´ë³´ì„¸ìš”.</p>
        
        <a href="https://www.instagram.com/jake._.hi" target="_blank" class="modal-btn">
            ğŸ“¸ ì¸ìŠ¤íƒ€ê·¸ë¨ êµ¬ê²½ê°€ê¸°
        </a>
    </div>

    <div id="joystick-zone"></div>
    <div id="jump-btn">JUMP</div>
    
    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

        // 1. ì”¬ ì„¤ì •
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB);
        scene.fog = new THREE.Fog(0x87CEEB, 20, 100);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        // 2. ì¡°ëª…
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        const sunLight = new THREE.DirectionalLight(0xffffff, 1.2);
        sunLight.position.set(20, 50, 20);
        sunLight.castShadow = true;
        scene.add(sunLight);

        // 3. ë§µ
        const sea = new THREE.Mesh(new THREE.PlaneGeometry(1000, 1000), new THREE.MeshStandardMaterial({ color: 0x1E90FF, roughness: 0.2 }));
        sea.rotation.x = -Math.PI / 2; sea.position.y = -1.5; scene.add(sea);

        const islandRadius = 30;
        const island = new THREE.Mesh(new THREE.CylinderGeometry(islandRadius, islandRadius, 3, 64), new THREE.MeshStandardMaterial({ color: 0x90EE90 }));
        island.position.y = -1.5; island.receiveShadow = true; scene.add(island);

        // --- ì‚¬ê³¼ & ë¯¸ì…˜ ë³€ìˆ˜ ---
        let apples = [];
        let appleScore = 0;
        const TARGET_SCORE = 10; // â˜… ë¯¸ì…˜ ëª©í‘œ ê°œìˆ˜
        const scoreBoard = document.getElementById('score-board');
        const missionModal = document.getElementById('mission-modal');

        function createApple(x, y, z) {
            const appleGeo = new THREE.SphereGeometry(0.3, 16, 16);
            const appleMat = new THREE.MeshStandardMaterial({ color: 0xFF0000, roughness: 0.3 });
            const apple = new THREE.Mesh(appleGeo, appleMat);
            apple.position.set(x, y, z); apple.castShadow = true;
            apple.userData = { originalY: y, offset: Math.random() * 100, isCollected: false };
            scene.add(apple);
            apples.push(apple);
        }

        function createTree(x, z) {
            const group = new THREE.Group();
            const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.4, 1.5, 8), new THREE.MeshStandardMaterial({ color: 0x8B4513 }));
            trunk.position.y = 0.75; trunk.castShadow = true;
            const leaves = new THREE.Mesh(new THREE.DodecahedronGeometry(1.2), new THREE.MeshStandardMaterial({ color: 0x228B22 }));
            leaves.position.y = 2; leaves.castShadow = true;
            group.add(trunk); group.add(leaves); group.position.set(x, 0, z);
            group.userData = { offset: Math.random() * 100 };
            scene.add(group);
            for(let k=0; k<3; k++) {
                const ax = x + (Math.random() - 0.5) * 1.5;
                const az = z + (Math.random() - 0.5) * 1.5;
                const ay = 1.5 + Math.random() * 1.0;
                createApple(ax, ay, az);
            }
            return group;
        }

        const trees = [];
        for(let i=0; i<20; i++) {
            const angle = Math.random() * Math.PI * 2;
            const r = 8 + Math.random() * (islandRadius - 10);
            trees.push(createTree(Math.cos(angle) * r, Math.sin(angle) * r));
        }

        // 4. ìºë¦­í„° ë¡œë“œ
        let playerModel = null, npcModel = null;
        let playerMixer = null, npcMixer = null;
        let playerActions = {}, npcActions = {};
        let activeAction = null;
        const loader = new GLTFLoader();
        const modelUrl = 'https://threejs.org/examples/models/gltf/RobotExpressive/RobotExpressive.glb';

        loader.load(modelUrl, function (gltf) {
            playerModel = gltf.scene;
            playerModel.traverse(o => { if(o.isMesh) o.castShadow = true; });
            playerModel.scale.set(0.5, 0.5, 0.5); playerModel.position.set(0, 10, 0);
            scene.add(playerModel);
            document.getElementById('loading').style.opacity = 0;

            const animations = gltf.animations;
            if (animations && animations.length > 0) {
                playerMixer = new THREE.AnimationMixer(playerModel);
                playerActions['Idle'] = playerMixer.clipAction(THREE.AnimationClip.findByName(animations, 'Idle'));
                playerActions['Walking'] = playerMixer.clipAction(THREE.AnimationClip.findByName(animations, 'Walking'));
                playerActions['Jump'] = playerMixer.clipAction(THREE.AnimationClip.findByName(animations, 'Jump'));
                playerActions['Death'] = playerMixer.clipAction(THREE.AnimationClip.findByName(animations, 'Death'));
                if(playerActions['Jump']) { playerActions['Jump'].setLoop(THREE.LoopOnce); playerActions['Jump'].clampWhenFinished = true; }
                if(playerActions['Death']) { playerActions['Death'].setLoop(THREE.LoopOnce); playerActions['Death'].clampWhenFinished = true; }
                activeAction = playerActions['Idle']; activeAction.play();
            }
        });

        loader.load(modelUrl, function (gltf) {
            npcModel = gltf.scene;
            npcModel.traverse(o => { 
                if(o.isMesh) {
                    o.castShadow = true; o.material = o.material.clone();
                    o.material.color.set(0xFFD700); o.material.metalness = 0.5; o.material.roughness = 0.3;
                }
            });
            npcModel.scale.set(0.6, 0.6, 0.6); npcModel.position.set(10, 0, -5); npcModel.rotation.y = -Math.PI / 2;
            scene.add(npcModel);
            const animations = gltf.animations;
            if (animations && animations.length > 0) {
                npcMixer = new THREE.AnimationMixer(npcModel);
                const dance = npcMixer.clipAction(THREE.AnimationClip.findByName(animations, 'Dance'));
                if(dance) dance.play();
            }
        });

        // --- 5. ì»¨íŠ¸ë¡¤ ---
        const keys = { w: false, a: false, s: false, d: false, space: false };
        const playerSpeed = 0.15;
        let verticalVelocity = 0; const gravity = -0.015; const jumpStrength = 0.4;
        let isGrounded = false; let isDead = false;

        function changePlayerStyle() {
            if (!playerModel) return;
            const randomColor = Math.random() * 0xffffff;
            playerModel.traverse((o) => {
                if (o.isMesh) { o.material = o.material.clone(); o.material.color.setHex(randomColor); }
            });
        }
        document.getElementById('style-btn').addEventListener('click', changePlayerStyle);

        window.addEventListener('keydown', (e) => {
            if(isDead) return;
            if (e.code === 'KeyW') keys.w = true; if (e.code === 'KeyS') keys.s = true;
            if (e.code === 'KeyA') keys.a = true; if (e.code === 'KeyD') keys.d = true;
            if (e.code === 'Space') keys.space = true;
        });
        window.addEventListener('keyup', (e) => {
            if (e.code === 'KeyW') keys.w = false; if (e.code === 'KeyS') keys.s = false;
            if (e.code === 'KeyA') keys.a = false; if (e.code === 'KeyD') keys.d = false;
            if (e.code === 'Space') keys.space = false;
        });

        const joystickZone = document.getElementById('joystick-zone');
        const joystickManager = nipplejs.create({ zone: joystickZone, mode: 'static', position: { left: '50%', top: '50%' }, color: 'white', size: 100 });
        let joystickData = { x: 0, y: 0, active: false };
        joystickManager.on('move', (evt, data) => { if(data && data.vector) { joystickData.active = true; joystickData.x = data.vector.x; joystickData.y = data.vector.y; } });
        joystickManager.on('end', () => { joystickData.active = false; joystickData.x = 0; joystickData.y = 0; });

        const jumpBtn = document.getElementById('jump-btn');
        jumpBtn.addEventListener('touchstart', (e) => { e.preventDefault(); keys.space = true; });
        jumpBtn.addEventListener('touchend', (e) => { e.preventDefault(); keys.space = false; });
        jumpBtn.addEventListener('mousedown', () => keys.space = true);
        jumpBtn.addEventListener('mouseup', () => keys.space = false);

        function fadeToAction(name, duration) {
            if (!playerActions[name] || activeAction === playerActions[name]) return;
            const previousAction = activeAction;
            activeAction = playerActions[name];
            if (previousAction) previousAction.fadeOut(duration);
            activeAction.reset().fadeIn(duration).play();
        }

        function respawn() {
            playerModel.position.set(0, 10, 0); verticalVelocity = 0; isDead = false; isGrounded = false;
            document.getElementById('splash-screen').style.opacity = 0;
            fadeToAction('Idle', 0.5);
        }

        // --- 6. UI ëª¨ë‹¬ ê´€ë¦¬ ---
        const npcLabel = document.getElementById('npc-label');
        const infoModal = document.getElementById('info-modal');
        
        // NPC ëŒ€í™”
        npcLabel.addEventListener('click', () => infoModal.style.display = 'block');
        npcLabel.addEventListener('touchstart', (e) => { e.preventDefault(); infoModal.style.display = 'block'; });
        
        // ë‹«ê¸° ê¸°ëŠ¥ (ê³µí†µ)
        function closeModal(modalId) { document.getElementById(modalId).style.display = 'none'; }
        
        document.getElementById('close-info').onclick = () => closeModal('info-modal');
        document.getElementById('info-ok-btn').onclick = () => closeModal('info-modal');
        document.getElementById('close-mission').onclick = () => closeModal('mission-modal');


        // --- 7. ê²Œì„ ë£¨í”„ ---
        const clock = new THREE.Clock();
        const cameraOffset = new THREE.Vector3(0, 10, 14);

        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();
            const time = Date.now() * 0.001;

            if (playerMixer) playerMixer.update(delta);
            if (npcMixer) npcMixer.update(delta);

            if (playerModel && npcModel) {
                const dist = playerModel.position.distanceTo(npcModel.position);
                if (dist < 6) { 
                    npcLabel.style.display = 'block';
                    const npcHeadPos = npcModel.position.clone().add(new THREE.Vector3(0, 3.0, 0));
                    npcHeadPos.project(camera);
                    const x = (npcHeadPos.x * .5 + .5) * window.innerWidth;
                    const y = (-(npcHeadPos.y * .5) + .5) * window.innerHeight;
                    npcLabel.style.left = `${x}px`; npcLabel.style.top = `${y}px`;
                } else { npcLabel.style.display = 'none'; infoModal.style.display = 'none'; }
            }

            // ì‚¬ê³¼ ë¡œì§ & ë¯¸ì…˜ ì²´í¬
            if (playerModel) {
                apples.forEach((apple) => {
                    if (apple.userData.isCollected) return;
                    apple.position.y = apple.userData.originalY + Math.sin(time * 3 + apple.userData.offset) * 0.1;
                    apple.rotation.y += 0.02;
                    const playerCenter = playerModel.position.clone().add(new THREE.Vector3(0, 1, 0));
                    const dist = playerCenter.distanceTo(apple.position);

                    if (dist < 1.5) {
                        apple.userData.isCollected = true;
                        apple.visible = false;
                        appleScore++;
                        scoreBoard.innerText = `ğŸ ${appleScore} / ${TARGET_SCORE}`;
                        
                        // â˜… ë¯¸ì…˜ ë‹¬ì„± ì²´í¬ â˜…
                        if (appleScore === TARGET_SCORE) {
                            missionModal.style.display = 'block';
                            // ì¶•í•˜ íš¨ê³¼ìŒ ë“±ì„ ì—¬ê¸°ì— ë„£ì„ ìˆ˜ë„ ìˆìŒ
                        }
                    }
                });
            }

            if (playerModel) {
                let moveX = 0, moveZ = 0, isMoving = false;
                if (!isDead) {
                    if (keys.w) { moveZ -= playerSpeed; isMoving = true; }
                    if (keys.s) { moveZ += playerSpeed; isMoving = true; }
                    if (keys.a) { moveX -= playerSpeed; isMoving = true; }
                    if (keys.d) { moveX += playerSpeed; isMoving = true; }
                    if (joystickData.active) {
                        moveZ -= joystickData.y * playerSpeed;
                        moveX += joystickData.x * playerSpeed;
                        isMoving = true;
                    }
                }
                playerModel.position.x += moveX;
                playerModel.position.z += moveZ;

                const dist = Math.sqrt(playerModel.position.x**2 + playerModel.position.z**2);
                const isOnIsland = dist < (islandRadius - 1);

                if (keys.space && isGrounded && !isDead) {
                    verticalVelocity = jumpStrength;
                    isGrounded = false;
                    fadeToAction('Jump', 0.1);
                }
                verticalVelocity += gravity;
                playerModel.position.y += verticalVelocity;

                if (isOnIsland) {
                    if (playerModel.position.y <= 0) { playerModel.position.y = 0; verticalVelocity = 0; isGrounded = true; }
                } else { isGrounded = false; }

                if (playerModel.position.y < -2 && !isDead) {
                    isDead = true; fadeToAction('Death', 0.2);
                    document.getElementById('splash-screen').style.opacity = 0.8;
                    setTimeout(respawn, 2000);
                }

                if (isMoving && !isDead) {
                    const angle = Math.atan2(moveX, moveZ);
                    playerModel.rotation.y = angle;
                    if (isGrounded) fadeToAction('Walking', 0.2);
                } else {
                    if (isGrounded && !isDead) {
                        if (!playerActions['Jump'] || !playerActions['Jump'].isRunning()) {
                            fadeToAction('Idle', 0.2);
                        }
                    }
                }

                const targetCameraPos = playerModel.position.clone().add(cameraOffset);
                camera.position.lerp(targetCameraPos, 0.1);
                camera.lookAt(playerModel.position);
            }

            sea.position.y = -1.5 + Math.sin(time * 0.5) * 0.1;
            trees.forEach(tree => { tree.rotation.z = Math.sin(time * 2 + tree.userData.offset) * 0.05; });

            renderer.render(scene, camera);
        }

        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>