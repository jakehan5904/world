<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>My Coastal World - Step 3 (Jump & Trees)</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #87CEEB; }
        
        /* 설명 문구 스타일 복구 */
        #instructions {
            position: absolute;
            top: 20px;
            width: 100%;
            text-align: center;
            color: white;
            font-family: 'Inter', sans-serif;
            font-weight: bold;
            font-size: 1.2rem;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            pointer-events: none;
            z-index: 10;
        }

        #loading {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: white; font-weight: bold; font-size: 20px; text-shadow: 1px 1px 2px black;
            transition: opacity 0.5s;
        }
    </style>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>
    <div id="instructions">WASD: 이동 | SPACE: 점프</div>
    <div id="loading">로봇 조립 중...</div>
    
    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

        // --- 1. 기본 씬 설정 ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB);
        scene.fog = new THREE.Fog(0x87CEEB, 20, 100);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        // --- 2. 조명 ---
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        const sunLight = new THREE.DirectionalLight(0xffffff, 1.2);
        sunLight.position.set(20, 50, 20);
        sunLight.castShadow = true;
        scene.add(sunLight);

        // --- 3. 맵 (바다, 섬, 나무 복구!) ---
        const sea = new THREE.Mesh(
            new THREE.PlaneGeometry(1000, 1000),
            new THREE.MeshStandardMaterial({ color: 0x1E90FF, roughness: 0.2 })
        );
        sea.rotation.x = -Math.PI / 2;
        sea.position.y = -1;
        scene.add(sea);

        const island = new THREE.Mesh(
            new THREE.CylinderGeometry(25, 25, 2, 64), // 섬을 좀 더 넓혔습니다
            new THREE.MeshStandardMaterial({ color: 0x90EE90 })
        );
        island.position.y = -0.5;
        island.receiveShadow = true;
        scene.add(island);

        // ★ 나무 생성 함수 복구 ★
        function createTree(x, z) {
            const group = new THREE.Group();
            
            // 기둥
            const trunk = new THREE.Mesh(
                new THREE.CylinderGeometry(0.3, 0.4, 1.5, 8),
                new THREE.MeshStandardMaterial({ color: 0x8B4513 })
            );
            trunk.position.y = 0.75;
            trunk.castShadow = true;
            
            // 잎
            const leaves = new THREE.Mesh(
                new THREE.DodecahedronGeometry(1.2),
                new THREE.MeshStandardMaterial({ color: 0x228B22 })
            );
            leaves.position.y = 2;
            leaves.castShadow = true;

            group.add(trunk);
            group.add(leaves);
            group.position.set(x, 0, z);
            
            // 애니메이션용 데이터
            group.userData = { offset: Math.random() * 100 }; 
            
            scene.add(group);
            return group;
        }

        // 나무 심기 루프
        const trees = [];
        for(let i=0; i<15; i++) {
            const angle = Math.random() * Math.PI * 2;
            const radius = 5 + Math.random() * 15; // 중앙 비우고 외곽에 심기
            trees.push(createTree(Math.cos(angle) * radius, Math.sin(angle) * radius));
        }

        // --- 4. 캐릭터 & 애니메이션 ---
        let playerModel = null;
        let mixer = null;
        let actions = {}; // 동작들 저장소
        let activeAction = null; // 현재 재생 중인 동작

        const loader = new GLTFLoader();
        const modelUrl = 'https://threejs.org/examples/models/gltf/RobotExpressive/RobotExpressive.glb';

        loader.load(modelUrl, function (gltf) {
            playerModel = gltf.scene;
            playerModel.traverse(o => { if(o.isMesh) o.castShadow = true; });

            playerModel.scale.set(0.5, 0.5, 0.5); 
            playerModel.position.y = 0.5; // 땅 위에 배치

            scene.add(playerModel);
            document.getElementById('loading').style.opacity = 0; // 로딩 숨기기

            // 애니메이션 설정
            const animations = gltf.animations;
            if (animations && animations.length > 0) {
                mixer = new THREE.AnimationMixer(playerModel);
                
                // 필요한 동작 찾기
                actions['Idle'] = mixer.clipAction(THREE.AnimationClip.findByName(animations, 'Idle'));
                actions['Walking'] = mixer.clipAction(THREE.AnimationClip.findByName(animations, 'Walking'));
                actions['Jump'] = mixer.clipAction(THREE.AnimationClip.findByName(animations, 'Jump'));
                
                // 점프는 반복되면 안 되므로 설정
                if(actions['Jump']) {
                    actions['Jump'].setLoop(THREE.LoopOnce);
                    actions['Jump'].clampWhenFinished = true;
                }

                activeAction = actions['Idle'];
                activeAction.play();
            }

        }, undefined, function (error) { console.error(error); });

        // --- 5. 컨트롤 & 물리 변수 (점프 추가!) ---
        const keys = { w: false, a: false, s: false, d: false, space: false };
        const playerSpeed = 0.15;
        
        // ★ 점프 관련 변수 ★
        let verticalVelocity = 0; // 수직 속도
        const gravity = -0.015;   // 중력 (내려가는 힘)
        const jumpStrength = 0.4; // 점프 힘 (올라가는 힘)
        const groundLevel = 0.5;  // 바닥 높이
        let isGrounded = true;    // 땅에 닿아있는지 확인

        window.addEventListener('keydown', (e) => {
            const key = e.key.toLowerCase();
            if (keys.hasOwnProperty(key)) keys[key] = true;
            if (e.code === 'Space') keys.space = true; // 스페이스바
        });
        window.addEventListener('keyup', (e) => {
            const key = e.key.toLowerCase();
            if (keys.hasOwnProperty(key)) keys[key] = false;
            if (e.code === 'Space') keys.space = false;
        });

        // 애니메이션 전환 함수
        function fadeToAction(name, duration) {
            if (!actions[name] || activeAction === actions[name]) return;
            const previousAction = activeAction;
            activeAction = actions[name];
            
            if (previousAction) previousAction.fadeOut(duration);
            activeAction.reset().fadeIn(duration).play();
        }

        // --- 6. 애니메이션 루프 ---
        const clock = new THREE.Clock();
        const cameraOffset = new THREE.Vector3(0, 8, 12);

        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();

            if (mixer) mixer.update(delta);

            if (playerModel) {
                // 1. 이동 (WASD)
                let moveX = 0;
                let moveZ = 0;
                let isMoving = false;

                if (keys.w) { moveZ -= playerSpeed; isMoving = true; }
                if (keys.s) { moveZ += playerSpeed; isMoving = true; }
                if (keys.a) { moveX -= playerSpeed; isMoving = true; }
                if (keys.d) { moveX += playerSpeed; isMoving = true; }

                playerModel.position.x += moveX;
                playerModel.position.z += moveZ;

                // 2. 점프 & 중력 처리 (핵심!)
                if (keys.space && isGrounded) {
                    verticalVelocity = jumpStrength; // 위로 솟구침
                    isGrounded = false;
                    
                    // 점프 애니메이션 재생 (있으면)
                    fadeToAction('Jump', 0.1);
                }

                // 중력 적용
                verticalVelocity += gravity; 
                playerModel.position.y += verticalVelocity;

                // 땅에 닿았는지 체크 (간단한 충돌 처리)
                if (playerModel.position.y <= groundLevel) {
                    playerModel.position.y = groundLevel; // 땅 위로 고정
                    verticalVelocity = 0;
                    isGrounded = true;
                }

                // 3. 회전 및 걷기 애니메이션
                if (isMoving) {
                    const angle = Math.atan2(moveX, moveZ);
                    playerModel.rotation.y = angle;
                    
                    if (isGrounded) fadeToAction('Walking', 0.2);
                } else {
                    if (isGrounded && (!actions['Jump'] || !actions['Jump'].isRunning())) {
                        fadeToAction('Idle', 0.2);
                    }
                }

                // 4. 카메라 추적 (점프할 때 카메라도 같이 위로 가도록)
                const targetCameraPos = playerModel.position.clone().add(cameraOffset);
                camera.position.lerp(targetCameraPos, 0.1); // 0.1로 높여서 좀 더 빠릿하게
                camera.lookAt(playerModel.position);
            }

            // 환경 효과
            const time = Date.now() * 0.001;
            sea.position.y = -1 + Math.sin(time * 0.5) * 0.1;
            trees.forEach(tree => {
                tree.rotation.z = Math.sin(time * 2 + tree.userData.offset) * 0.05;
            });

            renderer.render(scene, camera);
        }

        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>