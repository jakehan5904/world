<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>HiNOMAD WORLD</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #87CEEB; }
        
        /* UI: ì¡°ì‘ ì„¤ëª… */
        #instructions {
            position: absolute; top: 20px; width: 100%; text-align: center;
            color: white; font-family: 'Inter', sans-serif; font-weight: bold; font-size: 1.2rem;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5); pointer-events: none; z-index: 10;
        }
        
        /* UI: ë¡œë”© í™”ë©´ */
        #loading {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: white; font-weight: bold; font-size: 20px; text-shadow: 1px 1px 2px black;
            transition: opacity 0.5s; pointer-events: none;
        }
        
        /* UI: ë¬¼ì— ë¹ ì§ íš¨ê³¼ */
        #splash-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(0, 100, 255, 0.5); opacity: 0;
            pointer-events: none; transition: opacity 0.2s; z-index: 5;
        }

        /* â˜… UI: NPC ë§í’ì„  ë²„íŠ¼ (í‰ì†Œì—” ìˆ¨ê¹€) â˜… */
        #npc-label {
            position: absolute;
            background: white;
            color: #333;
            padding: 8px 16px;
            border-radius: 20px;
            font-weight: bold;
            font-family: sans-serif;
            cursor: pointer;
            box-shadow: 0 4px 10px rgba(0,0,0,0.2);
            transform: translate(-50%, -100%); /* ì¤‘ì•™ ì •ë ¬ */
            display: none; /* ì•ˆ ë³´ì„ */
            z-index: 20;
            border: 2px solid #00ffff;
        }
        #npc-label:hover {
            background: #00ffff;
            color: black;
        }

        /* â˜… UI: ì„¤ëª… ëª¨ë‹¬ì°½ (íŒì—…) â˜… */
        #info-modal {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 40px;
            border-radius: 15px;
            text-align: center;
            display: none; /* ì•ˆ ë³´ì„ */
            z-index: 30;
            backdrop-filter: blur(5px);
            border: 1px solid #555;
            min-width: 300px;
        }
        #info-modal h2 { margin-top: 0; color: #00ffff; }
        #info-modal p { font-size: 1.2rem; line-height: 1.6; }
        #close-btn {
            margin-top: 20px;
            padding: 10px 20px;
            background: #00ffff;
            border: none;
            border-radius: 5px;
            font-weight: bold;
            cursor: pointer;
        }
    </style>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>
    <div id="instructions">WASD: ì´ë™ | SPACE: ì í”„ | NPCë¥¼ ì°¾ì•„ë³´ì„¸ìš”!</div>
    <div id="loading">HiNOMAD WORLD ìƒì„± ì¤‘...</div>
    <div id="splash-screen"></div>

    <div id="npc-label">About HiNOMAD ğŸ’¬</div>

    <div id="info-modal">
        <h2>HiNOMAD</h2>
        <p>We create the future.</p>
        <button id="close-btn">ë‹«ê¸°</button>
    </div>
    
    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

        // 1. ì”¬ ì„¤ì •
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB);
        scene.fog = new THREE.Fog(0x87CEEB, 20, 100);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        // 2. ì¡°ëª…
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        const sunLight = new THREE.DirectionalLight(0xffffff, 1.2);
        sunLight.position.set(20, 50, 20);
        sunLight.castShadow = true;
        scene.add(sunLight);

        // 3. ë§µ (ë°”ë‹¤ & ì„¬)
        const sea = new THREE.Mesh(
            new THREE.PlaneGeometry(1000, 1000),
            new THREE.MeshStandardMaterial({ color: 0x1E90FF, roughness: 0.2 })
        );
        sea.rotation.x = -Math.PI / 2;
        sea.position.y = -1.5;
        scene.add(sea);

        const islandRadius = 30; // ì„¬ì„ ì¢€ ë” í‚¤ì› ìŠµë‹ˆë‹¤
        const island = new THREE.Mesh(
            new THREE.CylinderGeometry(islandRadius, islandRadius, 3, 64),
            new THREE.MeshStandardMaterial({ color: 0x90EE90 })
        );
        island.position.y = -1.5;
        island.receiveShadow = true;
        scene.add(island);

        // ë‚˜ë¬´ ì‹¬ê¸°
        function createTree(x, z) {
            const group = new THREE.Group();
            const trunk = new THREE.Mesh(
                new THREE.CylinderGeometry(0.3, 0.4, 1.5, 8),
                new THREE.MeshStandardMaterial({ color: 0x8B4513 })
            );
            trunk.position.y = 0.75; trunk.castShadow = true;
            const leaves = new THREE.Mesh(
                new THREE.DodecahedronGeometry(1.2),
                new THREE.MeshStandardMaterial({ color: 0x228B22 })
            );
            leaves.position.y = 2; leaves.castShadow = true;
            group.add(trunk); group.add(leaves);
            group.position.set(x, 0, z);
            group.userData = { offset: Math.random() * 100 };
            scene.add(group);
            return group;
        }

        const trees = [];
        for(let i=0; i<20; i++) {
            const angle = Math.random() * Math.PI * 2;
            const r = 8 + Math.random() * (islandRadius - 10);
            trees.push(createTree(Math.cos(angle) * r, Math.sin(angle) * r));
        }

        // --- 4. ìºë¦­í„° ë¡œë“œ (í”Œë ˆì´ì–´ & NPC) ---
        let playerModel = null, npcModel = null;
        let playerMixer = null, npcMixer = null;
        let playerActions = {}, npcActions = {};
        let activeAction = null;
        
        const loader = new GLTFLoader();
        const modelUrl = 'https://threejs.org/examples/models/gltf/RobotExpressive/RobotExpressive.glb';

        // 4-1. í”Œë ˆì´ì–´ ë¡œë“œ
        loader.load(modelUrl, function (gltf) {
            playerModel = gltf.scene;
            playerModel.traverse(o => { if(o.isMesh) o.castShadow = true; });
            playerModel.scale.set(0.5, 0.5, 0.5);
            playerModel.position.set(0, 10, 0); // í•˜ëŠ˜ ë“±ì¥
            scene.add(playerModel);
            
            document.getElementById('loading').style.opacity = 0;

            const animations = gltf.animations;
            if (animations && animations.length > 0) {
                playerMixer = new THREE.AnimationMixer(playerModel);
                playerActions['Idle'] = playerMixer.clipAction(THREE.AnimationClip.findByName(animations, 'Idle'));
                playerActions['Walking'] = playerMixer.clipAction(THREE.AnimationClip.findByName(animations, 'Walking'));
                playerActions['Jump'] = playerMixer.clipAction(THREE.AnimationClip.findByName(animations, 'Jump'));
                playerActions['Death'] = playerMixer.clipAction(THREE.AnimationClip.findByName(animations, 'Death'));

                if(playerActions['Jump']) {
                    playerActions['Jump'].setLoop(THREE.LoopOnce);
                    playerActions['Jump'].clampWhenFinished = true;
                }
                if(playerActions['Death']) {
                    playerActions['Death'].setLoop(THREE.LoopOnce);
                    playerActions['Death'].clampWhenFinished = true;
                }

                activeAction = playerActions['Idle'];
                activeAction.play();
            }
        });

        // 4-2. NPC ë¡œë“œ (ë˜‘ê°™ì€ ë¡œë´‡ì„ í•˜ë‚˜ ë” ë¡œë“œ)
        loader.load(modelUrl, function (gltf) {
            npcModel = gltf.scene;
            npcModel.traverse(o => { if(o.isMesh) o.castShadow = true; });
            npcModel.scale.set(0.5, 0.5, 0.5);
            
            // â˜… NPC ìœ„ì¹˜ ì„¤ì • (ì„¬ í•œìª½ì— ë°°ì¹˜) â˜…
            npcModel.position.set(10, 0, -5); 
            npcModel.rotation.y = -Math.PI / 2; // í”Œë ˆì´ì–´ ìª½ ë°”ë¼ë³´ê²Œ

            scene.add(npcModel);

            const animations = gltf.animations;
            if (animations && animations.length > 0) {
                npcMixer = new THREE.AnimationMixer(npcModel);
                // NPCëŠ” ê³„ì† ì†ì„ í”ë“¤ê²Œ ì„¤ì • (Wave ë™ì‘ì´ ì—†ìœ¼ë©´ Danceë‚˜ Jump ë“± í™œìš©)
                // RobotExpressiveì—ëŠ” 'Wave'ê°€ ì—†ì–´ì„œ 'Dance'ë‚˜ 'Jump'ë¥¼ ë£¨í”„ë¡œ ëŒë¦¼
                // ì—¬ê¸°ì„œëŠ” 'Jump'ë¥¼ ë°˜ë³µì‹œì¼œì„œ ì‹ ë‚˜ë³´ì´ê²Œ í•¨
                const npcAction = npcMixer.clipAction(THREE.AnimationClip.findByName(animations, 'Dance'));
                if(npcAction) npcAction.play();
                else {
                     // ëŒ„ìŠ¤ê°€ ì—†ìœ¼ë©´ Idle
                     const idle = npcMixer.clipAction(THREE.AnimationClip.findByName(animations, 'Idle'));
                     if(idle) idle.play();
                }
            }
        });

        // --- 5. ì»¨íŠ¸ë¡¤ & ë¬¼ë¦¬ ---
        const keys = { w: false, a: false, s: false, d: false, space: false };
        const playerSpeed = 0.15;
        let verticalVelocity = 0;
        const gravity = -0.015;
        const jumpStrength = 0.4;
        let isGrounded = false;
        let isDead = false;

        window.addEventListener('keydown', (e) => {
            if(isDead) return;
            if (e.code === 'KeyW') keys.w = true;
            if (e.code === 'KeyS') keys.s = true;
            if (e.code === 'KeyA') keys.a = true;
            if (e.code === 'KeyD') keys.d = true;
            if (e.code === 'Space') keys.space = true;
        });
        window.addEventListener('keyup', (e) => {
            if (e.code === 'KeyW') keys.w = false;
            if (e.code === 'KeyS') keys.s = false;
            if (e.code === 'KeyA') keys.a = false;
            if (e.code === 'KeyD') keys.d = false;
            if (e.code === 'Space') keys.space = false;
        });

        function fadeToAction(name, duration) {
            if (!playerActions[name] || activeAction === playerActions[name]) return;
            const previousAction = activeAction;
            activeAction = playerActions[name];
            if (previousAction) previousAction.fadeOut(duration);
            activeAction.reset().fadeIn(duration).play();
        }

        function respawn() {
            playerModel.position.set(0, 10, 0);
            verticalVelocity = 0;
            isDead = false;
            isGrounded = false;
            document.getElementById('splash-screen').style.opacity = 0;
            fadeToAction('Idle', 0.5);
        }

        // --- 6. UI ì´ë²¤íŠ¸ (NPC ëŒ€í™”) ---
        const npcLabel = document.getElementById('npc-label');
        const infoModal = document.getElementById('info-modal');
        const closeBtn = document.getElementById('close-btn');

        // ë§í’ì„  í´ë¦­ ì‹œ ëª¨ë‹¬ ì—´ê¸°
        npcLabel.addEventListener('click', () => {
            infoModal.style.display = 'block';
        });

        // ë‹«ê¸° ë²„íŠ¼ í´ë¦­ ì‹œ ëª¨ë‹¬ ë‹«ê¸°
        closeBtn.addEventListener('click', () => {
            infoModal.style.display = 'none';
        });


        // --- 7. ê²Œì„ ë£¨í”„ ---
        const clock = new THREE.Clock();
        const cameraOffset = new THREE.Vector3(0, 10, 14);

        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();

            if (playerMixer) playerMixer.update(delta);
            if (npcMixer) npcMixer.update(delta);

            // â˜… NPC ìƒí˜¸ì‘ìš© ë¡œì§ (ê±°ë¦¬ ê³„ì‚°) â˜…
            if (playerModel && npcModel) {
                const dist = playerModel.position.distanceTo(npcModel.position);
                
                // ê±°ë¦¬ 5m ì´ë‚´ë©´ ë§í’ì„  í‘œì‹œ
                if (dist < 5) {
                    npcLabel.style.display = 'block';
                    
                    // 3D ì¢Œí‘œ -> 2D í™”ë©´ ì¢Œí‘œ ë³€í™˜ (ë¨¸ë¦¬ ìœ„ì— ë„ìš°ê¸°)
                    // NPC ë¨¸ë¦¬ ìœ„ì¹˜ (í‚¤ê°€ ëŒ€ëµ 2më¼ê³  ê°€ì •í•˜ê³  y+2)
                    const npcHeadPos = npcModel.position.clone().add(new THREE.Vector3(0, 2.5, 0));
                    npcHeadPos.project(camera); // í™”ë©´ ì¢Œí‘œ(-1 ~ 1)ë¡œ ë³€í™˜

                    const x = (npcHeadPos.x * .5 + .5) * window.innerWidth;
                    const y = (-(npcHeadPos.y * .5) + .5) * window.innerHeight;

                    npcLabel.style.left = `${x}px`;
                    npcLabel.style.top = `${y}px`;

                } else {
                    npcLabel.style.display = 'none';
                    infoModal.style.display = 'none'; // ë©€ì–´ì§€ë©´ ì°½ë„ ë‹«ê¸° (ì„ íƒì‚¬í•­)
                }
            }


            if (playerModel) {
                // ì´ë™ ë° ë¬¼ë¦¬ (ê¸°ì¡´ê³¼ ë™ì¼)
                let moveX = 0, moveZ = 0, isMoving = false;

                if (!isDead) {
                    if (keys.w) { moveZ -= playerSpeed; isMoving = true; }
                    if (keys.s) { moveZ += playerSpeed; isMoving = true; }
                    if (keys.a) { moveX -= playerSpeed; isMoving = true; }
                    if (keys.d) { moveX += playerSpeed; isMoving = true; }
                }

                playerModel.position.x += moveX;
                playerModel.position.z += moveZ;

                const dist = Math.sqrt(playerModel.position.x**2 + playerModel.position.z**2);
                const isOnIsland = dist < (islandRadius - 1);

                if (keys.space && isGrounded && !isDead) {
                    verticalVelocity = jumpStrength;
                    isGrounded = false;
                    fadeToAction('Jump', 0.1);
                }

                verticalVelocity += gravity;
                playerModel.position.y += verticalVelocity;

                if (isOnIsland) {
                    if (playerModel.position.y <= 0) {
                        playerModel.position.y = 0;
                        verticalVelocity = 0;
                        isGrounded = true;
                    }
                } else {
                    isGrounded = false;
                }

                if (playerModel.position.y < -2 && !isDead) {
                    isDead = true;
                    fadeToAction('Death', 0.2);
                    document.getElementById('splash-screen').style.opacity = 0.8;
                    setTimeout(respawn, 2000);
                }

                if (isMoving && !isDead) {
                    const angle = Math.atan2(moveX, moveZ);
                    playerModel.rotation.y = angle;
                    if (isGrounded) fadeToAction('Walking', 0.2);
                } else {
                    if (isGrounded && !isDead) {
                        if (!playerActions['Jump'] || !playerActions['Jump'].isRunning()) {
                            fadeToAction('Idle', 0.2);
                        }
                    }
                }

                const targetCameraPos = playerModel.position.clone().add(cameraOffset);
                camera.position.lerp(targetCameraPos, 0.1);
                camera.lookAt(playerModel.position);
            }

            const time = Date.now() * 0.001;
            sea.position.y = -1.5 + Math.sin(time * 0.5) * 0.1;
            trees.forEach(tree => {
                tree.rotation.z = Math.sin(time * 2 + tree.userData.offset) * 0.05;
            });

            renderer.render(scene, camera);
        }

        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>