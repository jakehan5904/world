<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>Super Mario World 3D</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #87CEEB; }
        
        /* UI 스타일 */
        #instructions {
            position: absolute; top: 20px; width: 100%; text-align: center;
            color: white; font-family: sans-serif; font-weight: bold; font-size: 1.2rem;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5); pointer-events: none; z-index: 10;
        }
        #loading {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: white; font-weight: bold; font-size: 20px; text-shadow: 1px 1px 2px black;
            transition: opacity 0.5s; pointer-events: none;
        }
        #splash-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(0, 100, 255, 0.5); opacity: 0;
            pointer-events: none; transition: opacity 0.2s; z-index: 5;
        }
    </style>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>
    <div id="instructions">WASD: 이동 | SPACE: 점프 (한글키 OK)</div>
    <div id="loading">마리오 모셔오는 중... (F12 콘솔 확인)</div>
    <div id="splash-screen"></div>
    
    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

        // ==========================================
        // ★ 설정 구역 (여기서 숫자를 바꾸세요!) ★
        // ==========================================
        const MODEL_URL = './mario.glb'; // 마리오 파일명
        const MARIO_SCALE = 0.01;        // ★ 마리오 크기 (너무 크면 0.01, 너무 작으면 1.0)
        const ISLAND_RADIUS = 24;        // 섬 크기
        // ==========================================

        // 1. 기본 씬 설정
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB);
        scene.fog = new THREE.Fog(0x87CEEB, 20, 100);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        // 2. 조명
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        const sunLight = new THREE.DirectionalLight(0xffffff, 1.2);
        sunLight.position.set(20, 50, 20);
        sunLight.castShadow = true;
        scene.add(sunLight);

        // 3. 맵 생성 (바다 & 섬 & 나무)
        const sea = new THREE.Mesh(
            new THREE.PlaneGeometry(1000, 1000),
            new THREE.MeshStandardMaterial({ color: 0x1E90FF, roughness: 0.2 })
        );
        sea.rotation.x = -Math.PI / 2;
        sea.position.y = -1.5;
        scene.add(sea);

        const island = new THREE.Mesh(
            new THREE.CylinderGeometry(ISLAND_RADIUS, ISLAND_RADIUS, 3, 64),
            new THREE.MeshStandardMaterial({ color: 0x90EE90 })
        );
        island.position.y = -1.5;
        island.receiveShadow = true;
        scene.add(island);

        function createTree(x, z) {
            const group = new THREE.Group();
            const trunk = new THREE.Mesh(
                new THREE.CylinderGeometry(0.3, 0.4, 1.5, 8),
                new THREE.MeshStandardMaterial({ color: 0x8B4513 })
            );
            trunk.position.y = 0.75; trunk.castShadow = true;
            const leaves = new THREE.Mesh(
                new THREE.DodecahedronGeometry(1.2),
                new THREE.MeshStandardMaterial({ color: 0x228B22 })
            );
            leaves.position.y = 2; leaves.castShadow = true;
            group.add(trunk); group.add(leaves);
            group.position.set(x, 0, z);
            group.userData = { offset: Math.random() * 100 };
            scene.add(group);
            return group;
        }

        const trees = [];
        for(let i=0; i<15; i++) {
            const angle = Math.random() * Math.PI * 2;
            const r = 5 + Math.random() * (ISLAND_RADIUS - 8);
            trees.push(createTree(Math.cos(angle) * r, Math.sin(angle) * r));
        }

        // 4. 캐릭터 로드 및 애니메이션 처리
        let playerModel = null;
        let mixer = null;
        let actions = {};
        let activeAction = null;
        const loader = new GLTFLoader();

        // 이름으로 애니메이션 찾는 도우미 함수
        function findClip(animations, nameList) {
            if (!animations) return null;
            for (const name of nameList) {
                const clip = animations.find(c => c.name.toLowerCase().includes(name.toLowerCase()));
                if (clip) return clip;
            }
            return null;
        }

        loader.load(MODEL_URL, function (gltf) {
            playerModel = gltf.scene;
            playerModel.traverse(o => { if(o.isMesh) o.castShadow = true; });

            // ★ 크기 조절 적용
            playerModel.scale.set(MARIO_SCALE, MARIO_SCALE, MARIO_SCALE);
            playerModel.position.y = 10; // 하늘에서 등장

            scene.add(playerModel);
            document.getElementById('loading').style.opacity = 0;

            // 콘솔에 애니메이션 정보 출력 (F12 확인용)
            console.log("발견된 애니메이션:", gltf.animations);

            const anims = gltf.animations;
            if (anims && anims.length > 0) {
                mixer = new THREE.AnimationMixer(playerModel);

                // 1. 동작 찾기 시도
                let idleClip = findClip(anims, ['Idle', 'Stand', 'Wait']);
                let walkClip = findClip(anims, ['Run', 'Walk', 'Move']);
                let jumpClip = findClip(anims, ['Jump', 'Hop']);
                let swimClip = findClip(anims, ['Swim']);

                // ★ 긴급 처방: Idle이나 Walk를 못 찾았으면, 그냥 첫 번째 동작(0번)을 쓴다!
                // (T자 자세 방지용)
                if (!idleClip && !walkClip) {
                    console.warn("특정 동작을 못 찾아서 첫 번째 동작을 강제로 적용합니다.");
                    idleClip = anims[0];
                    walkClip = anims[0];
                }

                // 액션 등록
                if (idleClip) actions['Idle'] = mixer.clipAction(idleClip);
                if (walkClip) actions['Walking'] = mixer.clipAction(walkClip);
                if (jumpClip) {
                    actions['Jump'] = mixer.clipAction(jumpClip);
                    actions['Jump'].setLoop(THREE.LoopOnce);
                    actions['Jump'].clampWhenFinished = true;
                }
                if (swimClip) actions['Swim'] = mixer.clipAction(swimClip);

                // 시작 애니메이션 재생
                if (actions['Idle']) {
                    activeAction = actions['Idle'];
                    activeAction.play();
                } else {
                    // 진짜 아무것도 없으면 첫번째거라도 재생
                     mixer.clipAction(anims[0]).play();
                }
            } else {
                console.error("이 파일에는 애니메이션이 전혀 없습니다!");
                document.getElementById('loading').innerText = "애니메이션 없음 (T-Pose 주의)";
                document.getElementById('loading').style.opacity = 1;
            }

        }, undefined, function(err) {
            console.error(err);
            document.getElementById('loading').innerText = "파일 로드 실패 (파일명 확인)";
        });

        // 5. 컨트롤 & 물리 변수
        const keys = { w: false, a: false, s: false, d: false, space: false };
        const playerSpeed = 0.15;
        let verticalVelocity = 0;
        const gravity = -0.015;
        const jumpStrength = 0.4;
        const groundLevel = 0.0;
        let isGrounded = false;
        let isDead = false;

        // ★ 한글 키보드 지원 (e.code 사용)
        window.addEventListener('keydown', (e) => {
            if(isDead) return;
            if (e.code === 'KeyW') keys.w = true;
            if (e.code === 'KeyS') keys.s = true;
            if (e.code === 'KeyA') keys.a = true;
            if (e.code === 'KeyD') keys.d = true;
            if (e.code === 'Space') keys.space = true;
        });
        window.addEventListener('keyup', (e) => {
            if (e.code === 'KeyW') keys.w = false;
            if (e.code === 'KeyS') keys.s = false;
            if (e.code === 'KeyA') keys.a = false;
            if (e.code === 'KeyD') keys.d = false;
            if (e.code === 'Space') keys.space = false;
        });

        // 애니메이션 부드럽게 전환
        function fadeToAction(name, duration) {
            if (!actions[name] || activeAction === actions[name]) return;
            const previousAction = activeAction;
            activeAction = actions[name];
            if (previousAction) previousAction.fadeOut(duration);
            activeAction.reset().fadeIn(duration).play();
        }

        // 부활 로직
        function respawn() {
            playerModel.position.set(0, 10, 0);
            verticalVelocity = 0;
            isDead = false;
            isGrounded = false;
            document.getElementById('splash-screen').style.opacity = 0;
            if(actions['Idle']) fadeToAction('Idle', 0.5);
        }

        // 6. 게임 루프
        const clock = new THREE.Clock();
        const cameraOffset = new THREE.Vector3(0, 10, 14);

        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();

            if (mixer) mixer.update(delta);

            if (playerModel) {
                let moveX = 0, moveZ = 0, isMoving = false;

                if (!isDead) {
                    if (keys.w) { moveZ -= playerSpeed; isMoving = true; }
                    if (keys.s) { moveZ += playerSpeed; isMoving = true; }
                    if (keys.a) { moveX -= playerSpeed; isMoving = true; }
                    if (keys.d) { moveX += playerSpeed; isMoving = true; }
                }

                playerModel.position.x += moveX;
                playerModel.position.z += moveZ;

                // 낙사 체크
                const dist = Math.sqrt(playerModel.position.x**2 + playerModel.position.z**2);
                const isOnIsland = dist < (ISLAND_RADIUS - 1);

                // 점프 & 중력
                if (keys.space && isGrounded && !isDead) {
                    verticalVelocity = jumpStrength;
                    isGrounded = false;
                    if(actions['Jump']) fadeToAction('Jump', 0.1);
                }

                verticalVelocity += gravity;
                playerModel.position.y += verticalVelocity;

                // 바닥 충돌
                if (isOnIsland) {
                    if (playerModel.position.y <= groundLevel) {
                        playerModel.position.y = groundLevel;
                        verticalVelocity = 0;
                        isGrounded = true;
                    }
                } else {
                    isGrounded = false;
                }

                // 사망 체크 (물에 빠짐)
                if (playerModel.position.y < -2 && !isDead) {
                    isDead = true;
                    // 수영 모션 있으면 재생, 없으면 점프나 걷기로 대체
                    if (actions['Swim']) fadeToAction('Swim', 0.2);
                    else if (actions['Jump']) fadeToAction('Jump', 0.2);
                    
                    document.getElementById('splash-screen').style.opacity = 0.8;
                    setTimeout(respawn, 2000);
                }

                // 회전 및 걷기 모션
                if (isMoving && !isDead) {
                    const angle = Math.atan2(moveX, moveZ);
                    playerModel.rotation.y = angle;
                    if (isGrounded) fadeToAction('Walking', 0.2);
                } else {
                    if (isGrounded && !isDead) {
                        // 점프 중이 아닐 때만 Idle
                        if (!actions['Jump'] || !actions['Jump'].isRunning()) {
                            fadeToAction('Idle', 0.2);
                        }
                    }
                }

                // 카메라 추적
                const targetCameraPos = playerModel.position.clone().add(cameraOffset);
                camera.position.lerp(targetCameraPos, 0.1);
                camera.lookAt(playerModel.position);
            }

            // 환경 효과
            const time = Date.now() * 0.001;
            sea.position.y = -1.5 + Math.sin(time * 0.5) * 0.1;
            trees.forEach(tree => {
                tree.rotation.z = Math.sin(time * 2 + tree.userData.offset) * 0.05;
            });

            renderer.render(scene, camera);
        }

        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>